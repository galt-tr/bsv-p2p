# Private Key Storage Security Audit

**Date:** February 19, 2026  
**Audited by:** Researcher  
**Component:** BSV P2P Payment Channels  
**Scope:** Private key storage in `~/.bsv-p2p/config.json`

---

## Executive Summary

**CRITICAL VULNERABILITY:** BSV private keys are currently stored in **plaintext** in `~/.bsv-p2p/config.json`. This poses significant security risks for production deployments:

- Any process or user with file system access can read private keys
- Keys are exposed in backups, logs, and config management tools
- Compromised keys enable theft of all funds and channel balances
- No defense against insider threats or malware

**Recommendation:** Implement OS keychain integration with encrypted file fallback before any mainnet usage. Priority: **HIGH**.

---

## Current State Analysis

### Code Locations
- Config structure: `src/daemon/index.ts` (interface `DaemonConfig`)
- Wallet initialization: `src/wallet/index.ts` (class `Wallet`)
- Init script: `scripts/init.ts` (generates keypairs)

### Current Implementation
```typescript
interface DaemonConfig {
  bsvIdentityKey?: string      // libp2p identity (hex)
  bsvPrivateKey?: string        // BSV wallet key (hex)
  bsvPublicKey?: string         // BSV public key (hex)
  // ... other fields
}
```

Keys are:
1. Generated by `scripts/init.ts` using `@bsv/sdk`
2. Written to `~/.bsv-p2p/config.json` in plaintext
3. Loaded at daemon startup without any authentication
4. Stored in memory for the lifetime of the process

**File Permissions:** Standard user file (0644 or 0600 depending on umask)  
**Encryption:** None  
**Access Control:** Filesystem-level only

---

## Threat Model

### Assets at Risk
1. **BSV private keys** ‚Äî control of wallet funds (potentially thousands of dollars)
2. **Channel states** ‚Äî ability to close channels early, potentially stealing funds
3. **Payment history** ‚Äî privacy implications

### Threat Actors
| Actor | Access Level | Likelihood | Impact |
|-------|-------------|-----------|--------|
| Malware on host | Full filesystem | Medium | Critical |
| Compromised backup | Read config file | High | Critical |
| Local attacker | Physical/SSH access | Low-Medium | Critical |
| Config management leak | CI/CD pipeline | Medium | Critical |
| Insider threat | Admin access | Low | Critical |
| Memory dump attack | Running process | Low | High |

### Attack Scenarios

**Scenario 1: Backup Exposure**
- User backs up `~/.bsv-p2p/` to cloud storage
- Backup service is compromised or misconfigured (public S3 bucket)
- Attacker extracts private keys from backup
- **Impact:** Complete loss of funds

**Scenario 2: Malware/Keylogger**
- User downloads compromised software
- Malware scans for crypto wallet files
- Finds `config.json`, extracts keys
- **Impact:** Silent theft over time

**Scenario 3: Docker/VM Escape**
- Bot runs in container with mounted volume
- Container escape or misconfigured volume permissions
- Host process reads config file
- **Impact:** Key theft across multiple bots

**Scenario 4: CI/CD Pipeline Leak**
- Config file checked into version control
- Secret scanning disabled or bypassed
- Keys exposed in commit history
- **Impact:** Public key disclosure

---

## Research Findings

### 1. OS Keychain Integration

#### Platform-Specific APIs

**macOS Keychain**
- API: Keychain Services (via Security framework)
- Storage: Encrypted keychain files (`~/Library/Keychains/`)
- Access control: Per-application entitlements + user authentication
- Biometric: Touch ID / Face ID support
- CLI: `security add-generic-password`, `security find-generic-password`

**Linux Secret Service**
- API: `org.freedesktop.Secret` D-Bus interface
- Implementations:
  - GNOME Keyring (most common)
  - KWallet (KDE)
  - Pass (CLI-based)
- Storage: Encrypted with master password
- Auto-unlock: On login (optional)

**Windows Credential Manager**
- API: Credential Management API (CredWrite/CredRead)
- Storage: Windows Credential Store (encrypted)
- Access control: Per-user, isolated by application
- GUI: Control Panel ‚Üí Credential Manager

#### Node.js Libraries

**@napi-rs/keyring** (Recommended)
- Successor to deprecated `keytar`
- Native bindings via napi-rs
- Cross-platform: macOS, Linux, Windows
- **Pros:**
  - Active maintenance
  - Fast (native code)
  - Type-safe (TypeScript)
  - Secure by default
- **Cons:**
  - Requires native compilation
  - Linux: needs `libsecret` installed
  - Headless: may need manual keychain unlock
- **Installation:**
  ```bash
  npm install @napi-rs/keyring
  ```
- **Usage:**
  ```typescript
  import { Keyring } from '@napi-rs/keyring'
  
  // Store
  const keyring = new Keyring('bsv-p2p', 'default')
  await keyring.setPassword('my-secret-key')
  
  // Retrieve
  const key = await keyring.getPassword()
  ```

**Alternative: credential-store**
- Pure JavaScript (no native deps)
- Simpler but less secure (file-based encryption)
- Good fallback for headless Linux

#### Pros and Cons

**Pros:**
- ‚úÖ Platform-native security
- ‚úÖ Automatic encryption at rest
- ‚úÖ OS-level access control
- ‚úÖ Biometric authentication (macOS/Windows)
- ‚úÖ Audited by OS vendors
- ‚úÖ Standard practice for production apps

**Cons:**
- ‚ùå Platform-specific complexity
- ‚ùå Requires `libsecret` on Linux (extra dependency)
- ‚ùå Headless servers may need manual unlock
- ‚ùå Docker containers need special setup
- ‚ùå Not all Linux distros have keyring by default

---

### 2. Encrypted File Storage

#### Approach: AES-256-GCM with Passphrase

**Design:**
1. User provides passphrase on daemon start
2. Derive encryption key: `scrypt(passphrase, salt, N=32768, r=8, p=1)`
3. Encrypt `config.json` with AES-256-GCM
4. Store encrypted file + salt + IV
5. Prompt for passphrase on each daemon start

**Security Properties:**
- **Encryption:** AES-256 (NIST approved, quantum-resistant for now)
- **KDF:** scrypt (memory-hard, resistant to GPU attacks)
- **Authentication:** GCM mode (authenticated encryption)
- **Salt:** Random per installation (prevents rainbow tables)

**Implementation Example:**
```typescript
import { scrypt, randomBytes, createCipheriv, createDecipheriv } from 'crypto'
import { promisify } from 'util'

const scryptAsync = promisify(scrypt)

async function encryptConfig(data: string, passphrase: string): Promise<EncryptedConfig> {
  const salt = randomBytes(32)
  const iv = randomBytes(16)
  const key = await scryptAsync(passphrase, salt, 32, { N: 32768, r: 8, p: 1 }) as Buffer
  
  const cipher = createCipheriv('aes-256-gcm', key, iv)
  const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()])
  const authTag = cipher.getAuthTag()
  
  return {
    version: 1,
    algorithm: 'aes-256-gcm',
    salt: salt.toString('hex'),
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex'),
    ciphertext: encrypted.toString('hex')
  }
}

async function decryptConfig(config: EncryptedConfig, passphrase: string): Promise<string> {
  const key = await scryptAsync(passphrase, Buffer.from(config.salt, 'hex'), 32, { N: 32768, r: 8, p: 1 }) as Buffer
  
  const decipher = createDecipheriv('aes-256-gcm', key, Buffer.from(config.iv, 'hex'))
  decipher.setAuthTag(Buffer.from(config.authTag, 'hex'))
  
  return decipher.update(config.ciphertext, 'hex', 'utf8') + decipher.final('utf8')
}
```

**Pros:**
- ‚úÖ Cross-platform (pure Node.js crypto)
- ‚úÖ No external dependencies
- ‚úÖ User-controlled passphrase
- ‚úÖ Can use hardware tokens (YubiKey) for passphrase
- ‚úÖ Works in Docker/headless with env var passphrase

**Cons:**
- ‚ùå User must enter passphrase on every start (UX friction)
- ‚ùå Passphrase in memory during runtime
- ‚ùå Vulnerable if passphrase is weak
- ‚ùå Not suitable for fully automated bots (needs human input)

---

### 3. Environment Variables

#### Approach: `BSV_PRIVATE_KEY` Environment Variable

**Design:**
```bash
export BSV_PRIVATE_KEY="your-hex-key-here"
bsv-p2p daemon start
```

Config loader falls back to env var if not in file:
```typescript
function loadConfig(): DaemonConfig {
  const config = loadConfigFile()
  
  if (!config.bsvPrivateKey && process.env.BSV_PRIVATE_KEY) {
    config.bsvPrivateKey = process.env.BSV_PRIVATE_KEY
  }
  
  return config
}
```

**Pros:**
- ‚úÖ Simple implementation
- ‚úÖ Keeps keys out of version control
- ‚úÖ Standard practice for 12-factor apps
- ‚úÖ Works well with Docker Secrets, Kubernetes Secrets
- ‚úÖ No user prompts needed

**Cons:**
- ‚ùå Visible in process listing (`ps aux | grep BSV_PRIVATE_KEY`)
- ‚ùå Leaked in error dumps, logs, monitoring tools
- ‚ùå Still plaintext (just in a different location)
- ‚ùå Child processes inherit environment
- ‚ùå Not meaningfully more secure than file storage

**Verdict:** **Better than plaintext files, but not a complete solution.**

---

### 4. Hardware Security Modules (HSMs)

#### Options

**Software HSMs:**
- **SoftHSM2** ‚Äî Open-source PKCS#11 implementation
- **HashiCorp Vault** ‚Äî Enterprise secret management
- **AWS KMS / Google Cloud KMS** ‚Äî Cloud provider HSMs

**Hardware HSMs:**
- **YubiKey** ‚Äî USB hardware token with PKCS#11
- **Ledger / Trezor** ‚Äî Cryptocurrency hardware wallets
- **Enterprise HSMs** ‚Äî Thales, Gemalto (overkill for bots)

**Pros:**
- ‚úÖ Private keys never leave hardware
- ‚úÖ Tamper-resistant
- ‚úÖ Audit trails
- ‚úÖ Compliance-friendly (PCI DSS, FIPS 140-2)

**Cons:**
- ‚ùå Complex setup
- ‚ùå Cost (hardware devices, cloud HSM pricing)
- ‚ùå Latency (network calls for cloud HSM)
- ‚ùå Not practical for bot-to-bot scenarios
- ‚ùå Overkill for testnet

**Verdict:** **Document for reference, but not recommended for P2P bot use case.**

---

### 5. Split Keys / Threshold Signatures

#### Approach: Shamir's Secret Sharing

**Design:**
- Split private key into N shares (e.g., 5)
- Require M shares to reconstruct (e.g., 3-of-5)
- Store shares in different locations (keychain, file, env var, etc.)
- Reconstruct key at runtime

**Pros:**
- ‚úÖ No single point of failure
- ‚úÖ Resilient to partial compromise
- ‚úÖ Good for multi-operator scenarios

**Cons:**
- ‚ùå Complex implementation
- ‚ùå Requires M locations to be available
- ‚ùå Not suitable for automated bots
- ‚ùå Reconstruction still produces key in memory

**Verdict:** **Interesting but too complex for current use case.**

---

## Recommendations (Ranked by Priority)

### Priority 1: Immediate (Required for Mainnet)

**1.1: OS Keychain Integration** ‚≠ê **Recommended**
- **Library:** `@napi-rs/keyring`
- **Scope:** macOS Keychain, Linux Secret Service, Windows Credential Manager
- **Migration:** Auto-migrate from plaintext config on first run
- **Fallback:** Encrypted file if keychain unavailable

**Implementation Steps:**
1. Add `@napi-rs/keyring` dependency
2. Create `src/config/keychain.ts` module
3. Add migration logic: detect plaintext keys ‚Üí prompt to move to keychain
4. Update `loadConfig()` to check keychain first, then file
5. Add CLI commands: `bsv-p2p config set-key`, `bsv-p2p config get-key`
6. Document Linux setup: `sudo apt install libsecret-1-dev`

**Code Structure:**
```typescript
// src/config/keychain.ts
import { Keyring } from '@napi-rs/keyring'

export class KeychainManager {
  private keyring: Keyring
  
  constructor(service = 'bsv-p2p', account = 'default') {
    this.keyring = new Keyring(service, account)
  }
  
  async setPrivateKey(key: string): Promise<void> {
    await this.keyring.setPassword(key)
  }
  
  async getPrivateKey(): Promise<string | null> {
    try {
      return await this.keyring.getPassword()
    } catch {
      return null
    }
  }
  
  async deletePrivateKey(): Promise<void> {
    await this.keyring.deletePassword()
  }
}

// Usage in loadConfig()
async function loadConfig(): Promise<DaemonConfig> {
  const keychain = new KeychainManager()
  const keychainKey = await keychain.getPrivateKey()
  
  if (keychainKey) {
    return { ...DEFAULT_CONFIG, bsvPrivateKey: keychainKey }
  }
  
  // Fallback to file
  const fileConfig = loadConfigFile()
  
  // Migration: if key in file, move to keychain
  if (fileConfig.bsvPrivateKey) {
    await keychain.setPrivateKey(fileConfig.bsvPrivateKey)
    console.log('Migrated key to OS keychain')
    // Optionally remove from file
  }
  
  return fileConfig
}
```

---

**1.2: Environment Variable Support**
- **Why:** Standard practice, Docker-friendly
- **Implementation:** Check `process.env.BSV_PRIVATE_KEY` before file
- **Priority:** High (easy win)

```typescript
function loadConfig(): DaemonConfig {
  const config = loadConfigFile()
  
  // Override with env vars
  if (process.env.BSV_PRIVATE_KEY) {
    config.bsvPrivateKey = process.env.BSV_PRIVATE_KEY
  }
  
  if (process.env.BSV_PUBLIC_KEY) {
    config.bsvPublicKey = process.env.BSV_PUBLIC_KEY
  }
  
  return config
}
```

---

**1.3: Encrypted Config File (Fallback)**
- **When:** Keychain unavailable (headless Linux, Docker without D-Bus)
- **Method:** AES-256-GCM with scrypt KDF
- **Passphrase:** From env var (`BSV_CONFIG_PASSPHRASE`) or prompt
- **File:** `~/.bsv-p2p/config.enc` (replaces `config.json`)

**Implementation:**
1. Add `config encrypt` CLI command
2. Check for `.enc` file first in `loadConfig()`
3. Prompt for passphrase if not in env var
4. Cache decrypted config in memory (not on disk)

---

### Priority 2: Operational Security

**2.1: Documentation Updates**
- **Threat model** ‚Äî what are the risks?
- **Security model** ‚Äî how do we mitigate them?
- **Deployment guide** ‚Äî testnet vs mainnet separation
- **Backup procedures** ‚Äî how to safely back up keys
- **Key rotation** ‚Äî how to change keys without losing funds

**Add to GETTING-STARTED.md:**
```markdown
## Security Best Practices

### Mainnet vs Testnet

- **Testnet:** Lower security is acceptable. Plaintext config is fine for development.
- **Mainnet:** NEVER use plaintext keys. Use OS keychain or encrypted config.

### Key Storage Options

| Method | Security | UX | Mainnet Ready? |
|--------|----------|-----|----------------|
| Plaintext file | ‚ùå Low | ‚úÖ Easy | ‚ùå No |
| Environment variable | ‚ö†Ô∏è Medium | ‚úÖ Easy | ‚ö†Ô∏è For small amounts only |
| OS keychain | ‚úÖ High | ‚úÖ Good | ‚úÖ Yes |
| Encrypted file | ‚úÖ High | ‚ö†Ô∏è Prompt needed | ‚úÖ Yes |
| Hardware HSM | ‚úÖ‚úÖ Very High | ‚ùå Complex | ‚úÖ Yes (overkill) |

### Setup for Mainnet

1. **Enable OS Keychain:**
   ```bash
   bsv-p2p config migrate-to-keychain
   ```

2. **Verify:**
   ```bash
   bsv-p2p config check-security
   ```

3. **Backup:**
   Export your private key to a secure location (not cloud storage):
   ```bash
   bsv-p2p config export-key --output ~/secure-usb/bsv-backup.txt
   ```

4. **Test Recovery:**
   ```bash
   bsv-p2p config import-key --input ~/secure-usb/bsv-backup.txt
   ```
```

---

**2.2: Config Security Audit CLI**
Add `bsv-p2p config check-security` command:
```typescript
async function checkSecurity(): Promise<void> {
  console.log('üîç Security Audit\n')
  
  // Check 1: Key storage method
  const keychain = new KeychainManager()
  const keychainKey = await keychain.getPrivateKey()
  
  if (keychainKey) {
    console.log('‚úÖ Private key stored in OS keychain')
  } else {
    const config = loadConfigFile()
    if (config.bsvPrivateKey) {
      console.log('‚ùå CRITICAL: Private key in plaintext file')
      console.log('   Fix: Run `bsv-p2p config migrate-to-keychain`')
    } else if (process.env.BSV_PRIVATE_KEY) {
      console.log('‚ö†Ô∏è  WARNING: Private key in environment variable')
      console.log('   Better: Use OS keychain')
    }
  }
  
  // Check 2: File permissions
  const configPath = getConfigFile()
  const stats = statSync(configPath)
  const mode = (stats.mode & parseInt('777', 8)).toString(8)
  
  if (mode === '600') {
    console.log('‚úÖ Config file permissions: 0600 (owner only)')
  } else {
    console.log(`‚ö†Ô∏è  Config file permissions: 0${mode} (should be 0600)`)
    console.log('   Fix: chmod 600 ~/.bsv-p2p/config.json')
  }
  
  // Check 3: Git repository
  const gitDir = join(getDataDir(), '.git')
  if (existsSync(gitDir)) {
    console.log('‚ùå CRITICAL: .bsv-p2p is a git repository')
    console.log('   Risk: Keys may be in commit history')
    console.log('   Fix: Remove git repo or use .gitignore')
  }
  
  // Check 4: Backup warnings
  console.log('\nüìã Backup Checklist:')
  console.log('   - Export key to secure offline storage')
  console.log('   - Do NOT store in cloud (Dropbox, Drive, etc.)')
  console.log('   - Encrypt external backups')
  console.log('   - Test recovery process')
}
```

---

**2.3: Secure Init Script**
Update `scripts/init.ts`:
```typescript
async function init() {
  console.log('üîê BSV P2P Setup\n')
  
  // Ask: testnet or mainnet?
  const network = await prompt('Network (testnet/mainnet): ')
  
  if (network === 'mainnet') {
    console.log('\n‚ö†Ô∏è  MAINNET MODE')
    console.log('Use OS keychain for key storage? (recommended)')
    const useKeychain = await promptYesNo('Use keychain? [Y/n]: ')
    
    if (useKeychain) {
      // Generate key, store in keychain
      const privateKey = PrivateKey.fromRandom()
      const keychain = new KeychainManager()
      await keychain.setPrivateKey(privateKey.toHex())
      
      console.log('‚úÖ Key stored in OS keychain')
      console.log('‚ö†Ô∏è  BACKUP YOUR KEY:')
      console.log(`   bsv-p2p config export-key --output ~/secure-backup.txt`)
    } else {
      console.log('\n‚ö†Ô∏è  WARNING: Using encrypted config file')
      const passphrase = await promptSecret('Enter passphrase: ')
      // ... encrypted file setup
    }
  } else {
    // Testnet: plaintext is okay
    console.log('üìù Generating testnet keys (plaintext)')
    // ... existing logic
  }
}
```

---

### Priority 3: Advanced Features (Future)

**3.1: Key Rotation**
- Allow changing BSV private key without losing channel states
- Requires migrating channel multisig addresses
- Complex but important for long-term security

**3.2: HSM Integration** (Optional)
- Add PKCS#11 support for hardware tokens
- Useful for high-value enterprise deployments
- Not needed for most bot-to-bot scenarios

**3.3: Multi-Signature Wallets**
- Require M-of-N signatures for payments above threshold
- Good for multi-operator scenarios
- Adds latency (multiple parties must sign)

---

## Implementation Roadmap

### Phase 1: Core Security (1-2 weeks)
- [ ] Add `@napi-rs/keyring` dependency
- [ ] Implement `KeychainManager` class
- [ ] Update `loadConfig()` with keychain fallback
- [ ] Add environment variable support
- [ ] Migration logic (plaintext ‚Üí keychain)

### Phase 2: CLI & UX (1 week)
- [ ] `config migrate-to-keychain` command
- [ ] `config check-security` audit tool
- [ ] `config export-key` / `import-key` backup tools
- [ ] Update init script with security prompts

### Phase 3: Documentation (3-4 days)
- [ ] Update GETTING-STARTED.md with security section
- [ ] Create docs/security/KEY-MANAGEMENT.md
- [ ] Add threat model documentation
- [ ] Write testnet vs mainnet guide

### Phase 4: Encrypted Config Fallback (1 week)
- [ ] Implement AES-256-GCM encryption
- [ ] `config encrypt` command
- [ ] Passphrase prompt in loadConfig()
- [ ] Fallback chain: keychain ‚Üí encrypted file ‚Üí plaintext

### Phase 5: Testing (3-5 days)
- [ ] Unit tests for KeychainManager
- [ ] Integration tests for migration
- [ ] Security audit tests (check-security command)
- [ ] Cross-platform testing (macOS, Linux, Windows)

---

## Testing Checklist

### Unit Tests
- [ ] KeychainManager stores/retrieves keys correctly
- [ ] Encryption/decryption with correct passphrase
- [ ] Decryption fails with wrong passphrase
- [ ] Environment variable override works
- [ ] Migration from plaintext doesn't lose keys

### Integration Tests
- [ ] Daemon starts with keychain-stored key
- [ ] Daemon starts with env var key
- [ ] Daemon starts with encrypted config
- [ ] Migration flow: plaintext ‚Üí keychain ‚Üí verify
- [ ] check-security command detects plaintext keys

### Manual Testing
- [ ] macOS Keychain Access shows stored key
- [ ] Linux seahorse shows stored key (GNOME)
- [ ] Windows Credential Manager shows stored key
- [ ] Docker container works with env var
- [ ] Passphrase prompt works in encrypted mode

---

## Migration Guide (for Users)

### For Existing Deployments

**If you're using testnet:**
No action required. Plaintext keys are acceptable for testnet.

**If you're using mainnet (or plan to):**

1. **Back up your current key:**
   ```bash
   cp ~/.bsv-p2p/config.json ~/bsv-backup-$(date +%Y%m%d).json
   chmod 600 ~/bsv-backup-*.json
   ```

2. **Migrate to OS keychain:**
   ```bash
   bsv-p2p config migrate-to-keychain
   ```

3. **Verify:**
   ```bash
   bsv-p2p config check-security
   ```

4. **Test daemon start:**
   ```bash
   bsv-p2p daemon start
   ```

5. **Secure your backup:**
   - Store on encrypted USB drive
   - Do NOT upload to cloud storage
   - Keep offline in safe location

---

## References

### Standards & Best Practices
- [OWASP Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)
- [NIST SP 800-57: Key Management](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)
- [CWE-321: Use of Hard-coded Cryptographic Key](https://cwe.mitre.org/data/definitions/321.html)
- [12-Factor App: Config](https://12factor.net/config)

### Libraries
- [@napi-rs/keyring](https://github.com/napi-rs/node-rs) ‚Äî Cross-platform keychain
- [libsecret](https://wiki.gnome.org/Projects/Libsecret) ‚Äî Linux secret service
- [credential-store](https://www.npmjs.com/package/credential-store) ‚Äî JS fallback

### Cryptography
- [Node.js Crypto Module](https://nodejs.org/api/crypto.html)
- [AES-256-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode) ‚Äî Authenticated encryption
- [scrypt](https://en.wikipedia.org/wiki/Scrypt) ‚Äî Memory-hard KDF

### Platform Documentation
- [macOS Keychain Services](https://developer.apple.com/documentation/security/keychain_services)
- [freedesktop.org Secret Service API](https://specifications.freedesktop.org/secret-service/)
- [Windows Credential Management](https://docs.microsoft.com/en-us/windows/win32/secauthn/credential-management)

---

## Follow-Up Tasks

I'll create implementation tasks on the task board:

1. **#TBD: Implement OS keychain integration** (Priority: High)
   - Add @napi-rs/keyring dependency
   - Create KeychainManager class
   - Update loadConfig() with keychain support

2. **#TBD: Add environment variable key support** (Priority: High)
   - Check BSV_PRIVATE_KEY env var
   - Update docs with examples

3. **#TBD: Implement encrypted config file fallback** (Priority: Medium)
   - AES-256-GCM encryption
   - Passphrase prompt or env var
   - Auto-detect .enc files

4. **#TBD: Add config security CLI commands** (Priority: Medium)
   - migrate-to-keychain
   - check-security
   - export-key / import-key

5. **#TBD: Update security documentation** (Priority: High)
   - GETTING-STARTED.md security section
   - docs/security/KEY-MANAGEMENT.md
   - Testnet vs mainnet guide

---

**End of Audit Report**

