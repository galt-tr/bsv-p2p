"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WriterUint8Array = void 0;
const BigNumber_js_1 = __importDefault(require("./BigNumber.js"));
const utils_js_1 = require("./utils.js");
/**
 * WriterUint8Array is a utility class for writing binary data into a dynamically
 * growing Uint8Array buffer. It provides methods to write various integer types
 * and variable-length integers, similar to the Writer class but optimized for
 * Uint8Array usage.
 */
class WriterUint8Array {
    constructor(bufs, initialCapacity = 256) {
        if ((bufs != null) && bufs.length > 0) {
            const totalLength = bufs.reduce((sum, buf) => sum + buf.length, 0);
            initialCapacity = Math.max(initialCapacity, totalLength);
        }
        this.buffer = new Uint8Array(initialCapacity);
        this.pos = 0;
        this.capacity = initialCapacity;
        if (bufs != null) {
            for (const buf of bufs) {
                this.write(buf);
            }
        }
    }
    /**
     * Returns the current length of written data
     */
    getLength() {
        return this.pos;
    }
    /**
     * @return the written data as Uint8Array copy of the internal buffer
     */
    toUint8Array() {
        return this.buffer.slice(0, this.pos);
    }
    /**
     * Legacy compatibility method â€“ returns number[] (Byte[])
     */
    toArray() {
        return Array.from(this.toUint8Array());
    }
    /**
     * @return the written data as Uint8Array. CAUTION: This is zero-copy subarray of the internal buffer).
     */
    toUint8ArrayZeroCopy() {
        return this.buffer.subarray(0, this.pos);
    }
    ensureCapacity(needed) {
        if (this.pos + needed > this.capacity) {
            let newCapacity = this.capacity * 2;
            while (this.pos + needed > newCapacity) {
                newCapacity *= 2;
            }
            const newBuffer = new Uint8Array(newCapacity);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
            this.capacity = newCapacity;
        }
    }
    write(bytes) {
        const data = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
        this.ensureCapacity(data.length);
        this.buffer.set(data, this.pos);
        this.pos += data.length;
        return this;
    }
    writeReverse(buf) {
        const data = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
        this.ensureCapacity(data.length);
        for (let i = data.length - 1; i >= 0; i--) {
            this.buffer[this.pos] = data[i];
            this.pos += 1;
        }
        return this;
    }
    writeUInt8(value) {
        this.ensureCapacity(1);
        this.buffer[this.pos] = value & 0xff;
        this.pos += 1;
        return this;
    }
    writeInt8(value) {
        this.writeUInt8(value);
        return this;
    }
    writeUInt16LE(value) {
        this.ensureCapacity(2);
        this.buffer[this.pos] = value & 0xff;
        this.buffer[this.pos + 1] = (value >> 8) & 0xff;
        this.pos += 2;
        return this;
    }
    writeUInt16BE(value) {
        this.ensureCapacity(2);
        this.buffer[this.pos] = (value >> 8) & 0xff;
        this.buffer[this.pos + 1] = value & 0xff;
        this.pos += 2;
        return this;
    }
    writeInt16LE(value) {
        this.writeUInt16LE(value & 0xffff);
        return this;
    }
    writeInt16BE(value) {
        this.writeUInt16BE(value & 0xffff);
        return this;
    }
    writeUInt32LE(value) {
        this.ensureCapacity(4);
        this.buffer[this.pos] = value & 0xff;
        this.buffer[this.pos + 1] = (value >> 8) & 0xff;
        this.buffer[this.pos + 2] = (value >> 16) & 0xff;
        this.buffer[this.pos + 3] = (value >> 24) & 0xff;
        this.pos += 4;
        return this;
    }
    writeUInt32BE(value) {
        this.ensureCapacity(4);
        this.buffer[this.pos] = (value >> 24) & 0xff;
        this.buffer[this.pos + 1] = (value >> 16) & 0xff;
        this.buffer[this.pos + 2] = (value >> 8) & 0xff;
        this.buffer[this.pos + 3] = value & 0xff;
        this.pos += 4;
        return this;
    }
    writeInt32LE(value) {
        this.writeUInt32LE(value >>> 0);
        return this;
    }
    writeInt32BE(value) {
        this.writeUInt32BE(value >>> 0);
        return this;
    }
    writeUInt64BEBn(bn) {
        const buf = bn.toArray('be', 8);
        this.write(buf);
        return this;
    }
    writeUInt64LEBn(bn) {
        const buf = bn.toArray('be', 8);
        this.writeReverse(buf);
        return this;
    }
    writeUInt64LE(n) {
        const buf = new BigNumber_js_1.default(n).toArray('be', 8);
        this.writeReverse(buf);
        return this;
    }
    writeVarIntNum(n) {
        const buf = utils_js_1.Writer.varIntNum(n);
        this.write(buf);
        return this;
    }
    writeVarIntBn(bn) {
        const buf = utils_js_1.Writer.varIntBn(bn);
        this.write(buf);
        return this;
    }
    /**
     * Resets the writer to empty state (reuses the buffer)
     */
    reset() {
        this.pos = 0;
    }
}
exports.WriterUint8Array = WriterUint8Array;
//# sourceMappingURL=WriterUint8Array.js.map